<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ë°© - Raid Starter Kit</title>
  <link rel="stylesheet" href="../styles/base.css"/>
</head>
<body>
  <header class="header">
    <div class="container">
      <div class="row" style="justify-content:space-between;">
        <div><h1 style="margin:0;font-size:24px;">ğŸ° Raid Room</h1></div>
        <div class="row"><a href="lobby.html" class="btn">ë¡œë¹„ë¡œ</a><button id="leaveRoom" class="btn danger">íƒˆí‡´</button></div>
      </div>
    </div>
  </header>

  <div class="container grid" style="grid-template-columns:1fr 450px;">
    <section>
      <div id="aiChat"></div>
      <div style="height:16px"></div>
      <div id="genChat"></div>
    </section>
    <aside>
      <div id="roomMeta" class="card"></div>
      <div style="height:16px"></div>
      <div id="slots"></div>
      <div style="height:16px"></div>
      <div id="hostCtrl" class="card" style="display:none;">
        <h4>í˜¸ìŠ¤íŠ¸ ì»¨íŠ¸ë¡¤</h4>
        <div class="row" style="align-items:center;margin-bottom:8px;">
          <label class="meta" style="min-width:84px">í”„ë¡¬í”„íŠ¸</label>
          <select id="promptSel" class="input" style="max-width:260px"></select>
          <a href="prompt.html" class="btn">í¸ì§‘</a>
        </div>
        <div class="row" style="align-items:center;margin-bottom:8px;">
          <label class="meta" style="min-width:84px">API í‚¤</label>
          <input id="apiKey" class="input" placeholder="Gemini API Key" style="max-width:260px"/>
          <button id="saveKey" class="btn">ì €ì¥</button>
        </div>
        <div class="card" style="margin-bottom:8px">
          <b>ë¯¸ë¦¬ë³´ê¸°</b>
          <pre id="promptPreview" class="mono" style="white-space:pre-wrap;max-height:160px;overflow:auto;margin-top:6px"></pre>
        </div>
        <div class="row" style="margin-bottom:8px;">
          <input id="speaker" class="input" placeholder="ë°œí™” ìŠ¬ë¡¯ (ìˆ«ì)" style="max-width:150px" />
          <button id="setSp" class="btn">ë°œí™”ì ì§€ì •</button>
        </div>
        <div class="row">
          <button id="runPrompt" class="btn">í”„ë¡¬í”„íŠ¸ ì‹¤í–‰</button>
          <button id="start" class="btn primary">ê²Œì„ ì‹œì‘</button>
        </div>
      </div>
    </aside>
  </div>

<script type="module">
  import { Store } from '../core/store.js';
  import { API } from '../core/api.js';
  import { WS } from '../core/ws.js';
    import { mountGeneralChat } from '../components/chat-general.js';
    import { mountAiChat } from '../components/chat-ai.js';
    import { mountSlotsGrid } from '../components/slots-grid.js';

    const params = new URLSearchParams(location.search);
    const roomId = params.get('room');
    if (!roomId){ alert('ë°© IDê°€ ì—†ìŠµë‹ˆë‹¤'); location.href = 'lobby.html'; }

    const clientId = Store.state.clientId;
    const myName = ()=>Store.state.name;

    // WS + chats + slots mount
    WS.connect();
    WS.join(roomId, clientId, myName());
    const genChat = mountGeneralChat(document.getElementById('genChat'), { roomId, clientId, nameGetter: myName });
    const aiChat = mountAiChat(document.getElementById('aiChat'), { roomId, clientId, nameGetter: myName });
    const slotsGrid = mountSlotsGrid(document.getElementById('slots'), {
      host:false,
      async onClaim(slotNo){ const char = Store.state.roster[0] || null; if(!char){ alert('ë¡œìŠ¤í„°ì— ìºë¦­í„°ê°€ ì—†ìŠµë‹ˆë‹¤'); return; } try{ await API.claim(roomId,{clientId,name:myName(),slotNo,char}); refresh(); }catch(e){ alert('ìŠ¬ë¡¯ ì ìœ  ì‹¤íŒ¨:' + e.message); } },
      async onRelease(){ try{ await API.release(roomId,{clientId}); refresh(); }catch(e){ alert('ìŠ¬ë¡¯ í•´ì œ ì‹¤íŒ¨:' + e.message); } },
      async onReady(){ try{ await API.ready(roomId,{clientId}); refresh(); }catch(e){ alert('ì¤€ë¹„ ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨:' + e.message); } },
      async onKick(slotNo){ if(!confirm('ì´ í”Œë ˆì´ì–´ë¥¼ ì¶”ë°©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return; try{ await API.kick(roomId,{clientId,targetSlot:slotNo}); refresh(); }catch(e){ alert('ì¶”ë°© ì‹¤íŒ¨:'+e.message); } }
    });

    const metaBox = document.getElementById('roomMeta'), hostBox = document.getElementById('hostCtrl'),
          promptSel = document.getElementById('promptSel'), promptPreview = document.getElementById('promptPreview'),
          apiKeyInput = document.getElementById('apiKey'), saveKeyBtn = document.getElementById('saveKey');

    let __AI_BUSY = false;

    // refresh/render functions (get room, render UI, set host flag, slots render, aiChat.updateSpeak ë“±.)
    async function refresh(){ try{ const {room} = await API.getRoom(roomId); render(room); }catch(e){ localStorage.removeItem('RSK_ACTIVE_ROOM'); console.error('ë°©ì´ ì—†ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤:', e); } }
    function render(room){
      metaBox.innerHTML = `<h4>${room.title}</h4><div class="meta">${room.desc}</div><div class="meta">ìƒíƒœ: ${room.status} Â· ëª¨ë“œ: ${room.aiMode} Â· ë°œí™”ì: ${room.speakerSlot}</div>`;
      window.IS_HOST = (room.hostId === clientId);
      const leaveBtn = document.getElementById('leaveRoom'); if(leaveBtn) leaveBtn.textContent = window.IS_HOST ? 'ë°© ì¢…ë£Œ(ì‚­ì œ)' : 'íƒˆí‡´';
      slotsGrid.render(room, clientId);
      const isHost = room.hostId === clientId;
      slotsGrid.setHost(isHost);
      hostBox.style.display = isHost ? 'block' : 'none';
      if(isHost){
        const prompts = Store.loadPrompts();
        promptSel.innerHTML = (prompts||[]).map(p=>`<option value="${p.id}">${p.label||p.id}</option>`).join('') || '<option value="">(ì €ì¥ëœ í”„ë¡¬í”„íŠ¸ ì—†ìŒ)</option>';
        const last = localStorage.getItem('RSK_ROOM_PROMPT_' + room.id) || '';
        promptSel.value = last;
        apiKeyInput.value = localStorage.getItem('RSK_ROOM_APIKEY_' + room.id) || '';
        updatePreview(room);
      }
      const mySlot = room.slots.find(s => (s.playerId || s.clientId) === clientId);
      const canSpeak = isHost || room.aiMode === 'free' || room.speakerSlot === mySlot?.slotNo;
      aiChat.updateSpeak(canSpeak, room.aiMode, room.speakerSlot);
    }

    // prompt/template/AI call helper (callGemini placeholder -> API to call LLM)
    function expandTemplate(tpl, room){ /* same template replacer as before */ 
      function getSlot(n){ return room.slots?.find(s=>s.slotNo===n) || {}; }
      function charAll(c){ if(!c) return ''; const lines=[]; lines.push(`${c.name||''}`); if(c.title) lines.push(`- ${c.title}`); if(c.desc) lines.push(c.desc); (c.abilities||[]).forEach((a,i)=>{ if(a?.name||a?.text) lines.push(`â€¢ (${i+1}) ${a.name||''} â€” ${a.text||''}`); }); return lines.filter(Boolean).join('\\n'); }
      return (tpl||'').replace(/\\{\\{\\s*([\\w.\\[\\]]+)\\s*\\}\\}/g, (_, key)=>{
        if(key.startsWith('slot')){ const m = key.match(/^slot(\\d+)\\.(.+)$/); if(!m) return ''; const n=parseInt(m[1],10); const rest=m[2]; const slot=getSlot(n); const c=slot.char||{}; if(rest==='char.all') return charAll(c); if(rest.startsWith('char.abilities[')){ const mm = rest.match(/^char\\.abilities\\[(\\d+)\\]\\.(name|text)$/); if(!mm) return ''; const idx=parseInt(mm[1],10)-1; const field=mm[2]; return c.abilities?.[idx]?.[field]||''; } const map={'char.name':c.name,'char.desc':c.desc,'char.title':c.title}; return map[rest]||''; }
        if(key.startsWith('me.')){ const mySlot = room.slots.find(s=> (s.playerId || s.clientId) === clientId); return expandTemplate(`{{slot${mySlot?.slotNo||1}.${key.slice(3)}}}`, room); }
        if(key==='room.title') return room.title||''; if(key==='room.desc') return room.desc||''; return '';
      });
    }

    async function callGemini(apiKey, text){
      // ì‚¬ìš©ì í™˜ê²½ì— ë§ì¶° ìˆ˜ì •: ë³¸ ì˜ˆì‹œëŠ” Gemini REST í˜¸ì¶œì„ ê°€ì •
      const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${encodeURIComponent(apiKey)}`;
      const body = { contents:[{ role:'user', parts:[{ text }] }] };
      const r = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
      if(!r.ok) throw new Error('HTTP '+r.status);
      const j = await r.json();
      return j?.candidates?.[0]?.content?.parts?.map(p=>p.text||'').join('\\n') || '(ë¹ˆ ì‘ë‹µ)';
    }

    // runPrompt ë²„íŠ¼
    document.getElementById('runPrompt')?.addEventListener('click', async ()=>{
      const prompts = Store.loadPrompts();
      const cur = prompts.find(p=>p.id === (promptSel.value||''));
      if(!cur){ alert('í”„ë¡¬í”„íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”'); return; }
      const key = (apiKeyInput.value||'').trim() || localStorage.getItem('RSK_ROOM_APIKEY_' + roomId) || '';
      if(!key){ alert('API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤'); return; }
      try{
        const { room } = await API.getRoom(roomId);
        const expanded = expandTemplate(cur.text||'', room);
        const resp = await callGemini(key, expanded);
        await API.runPrompt(roomId, { clientId, text: resp });
      }catch(e){ alert('í”„ë¡¬í”„íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨: ' + (e?.message || e)); }
    });

    // host actions
    hostBox.querySelector('#setSp')?.addEventListener('click', async ()=>{
      const slotNo = parseInt(hostBox.querySelector('#speaker').value,10);
      if(!slotNo) return;
      try{ await API.speaker(roomId,{clientId,slotNo}); refresh(); } catch(e){ alert('ë°œí™”ì ì§€ì • ì‹¤íŒ¨:'+ e.message); }
    });
    hostBox.querySelector('#start')?.addEventListener('click', async ()=>{
      try{ await API.start(roomId,{clientId}); } catch(e){ alert('ê²Œì„ ì‹œì‘ ì‹¤íŒ¨: ' + e.message); }
    });

    // CHAT_WS handling (AI auto response)
    WS.on('CHAT_PUSH', async (message) => {
      const msg = message.message;
      if (!msg || msg.roomId !== roomId) return;
      // render
      if (msg.kind === 'ai' || msg.channel === 'ai') { aiChat.log.push(msg.name, msg.text); }
      else { genChat.push(msg.name, msg.text); return; }

      // ignore system/ai self
      if(!msg.clientId) return;
      if(/^(?:\\[?AI\\]?|SYSTEM)$/i.test(msg.name||'')) return;
      if(__AI_BUSY) return;
      const key = (apiKeyInput.value||'').trim() || localStorage.getItem('RSK_ROOM_APIKEY_' + roomId) || '';
      if(!key) { console.warn('[AI] API í‚¤ ì—†ìŒ'); return; }
      try{
        __AI_BUSY = true;
        let promptText = msg.text || '';
        try{ const {room} = await API.getRoom(roomId); promptText = expandTemplate(promptText, room); }catch(_){}
        const resp = await callGemini(key, promptText);
        await API.runPrompt(roomId, { clientId, text: resp });
      }catch(e){ console.warn('[AI] ìë™ì‘ë‹µ ì‹¤íŒ¨:', e); } finally { __AI_BUSY = false; }
    });

    // ROOM_STATE
    WS.on('ROOM_STATE', (message) => { if(message.room?.id === roomId) render(message.room); });

    // leave / delete handler (host vs participant)
    document.getElementById('leaveRoom')?.addEventListener('click', async ()=>{
      if(window.IS_HOST){
        if(!confirm('ì •ë§ ì´ ë°©ì„ ì¢…ë£Œ(ì‚­ì œ)í• ê¹Œìš”?')) return;
        try{
          try {
            if (API.chat) await API.chat(roomId, { name: '[SYSTEM]', text: 'ë°©ì´ ì¢…ë£Œë©ë‹ˆë‹¤.' });
            else if (WS.emit) WS.emit('CHAT', { roomId, message:{ name:'[SYSTEM]', text:'ë°©ì´ ì¢…ë£Œë©ë‹ˆë‹¤.' } });
            else await fetch(`/api/rooms/${roomId}/chat`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name:'[SYSTEM]', text:'ë°©ì´ ì¢…ë£Œë©ë‹ˆë‹¤.' }) });
          } catch(e){ console.warn('ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨:', e); }
          await new Promise(r=>setTimeout(r,200));
          if(API.deleteRoom) await API.deleteRoom(roomId, { clientId });
          else {
            const res = await fetch(`/api/rooms/${roomId}/delete`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientId }) });
            if(!res.ok) throw new Error('ë°© ì‚­ì œ ì‹¤íŒ¨');
          }
        }catch(e){ alert('ë°© ì‚­ì œ ì¤‘ ì˜¤ë¥˜: ' + (e?.message||e)); return; }
      } else {
        if(!confirm('ì´ ë°©ì—ì„œ íƒˆí‡´í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        try{ try{ await API.release(roomId, { clientId }); } catch(_){} } catch(e){ alert('íƒˆí‡´ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ' + (e?.message||e)); return; }
      }
      localStorage.removeItem('RSK_ACTIVE_ROOM');
      location.href = 'lobby.html';
    });

    // init
    refresh();
  </script>
</body>
</html>
